package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"encoding/base64"
	"fmt"
	"log"

	"github.com/y7ls8i/kv/graphql/graph/model"
	"github.com/y7ls8i/kv/kv"
)

// Set is the resolver for the set field.
func (r *mutationResolver) Set(ctx context.Context, input model.SetInput) (bool, error) {
	decoded, err := base64.StdEncoding.DecodeString(input.Value)
	if err != nil {
		return false, fmt.Errorf("base64 decoding error: %w", err)
	}
	kv.Set(input.Name, input.Key, decoded)
	return true, nil
}

// Delete is the resolver for the delete field.
func (r *mutationResolver) Delete(ctx context.Context, input model.KeyInput) (bool, error) {
	kv.Delete(input.Name, input.Key)
	return true, nil
}

// Clear is the resolver for the clear field.
func (r *mutationResolver) Clear(ctx context.Context, name string) (bool, error) {
	kv.Clear(name)
	return true, nil
}

// Get is the resolver for the get field.
func (r *queryResolver) Get(ctx context.Context, input model.KeyInput) (*model.GetResponse, error) {
	v, ok := kv.Get(input.Name, input.Key)
	if !ok {
		return &model.GetResponse{Ok: false}, nil
	}

	return &model.GetResponse{Value: base64.StdEncoding.EncodeToString(v), Ok: ok}, nil
}

// Length is the resolver for the length field.
func (r *queryResolver) Length(ctx context.Context, name string) (*model.LengthResponse, error) {
	return &model.LengthResponse{Length: int32(kv.Length(name))}, nil
}

// Subscribe is the resolver for the subscribe field.
func (r *subscriptionResolver) Subscribe(ctx context.Context, input model.KeyInput) (<-chan *model.Change, error) {
	subID, kvCh := kv.Subscribe(input.Name, input.Key)
	log.Printf("Subscribed name=%q key=%q id=%q", input.Name, input.Key, subID)

	outCh := make(chan *model.Change)

	go func() {
		defer func(name, key, subID string) {
			kv.Unsubscribe(name, subID)
			log.Printf("Unsubscribed name=%q key=%q id=%q", name, key, subID)

			close(outCh)
		}(input.Name, input.Key, subID)

		for {
			select {
			case <-ctx.Done():
				return

			case change := <-kvCh:
				send := model.Change{Value: base64.StdEncoding.EncodeToString(change.Value)}
				switch change.Op {
				case kv.OperationAdd:
					send.Operation = model.OperationAdd
				case kv.OperationUpdate:
					send.Operation = model.OperationUpdate
				case kv.OperationDelete:
					send.Operation = model.OperationDelete
				}
				outCh <- &send
			}
		}
	}()

	return outCh, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type (
	mutationResolver     struct{ *Resolver }
	queryResolver        struct{ *Resolver }
	subscriptionResolver struct{ *Resolver }
)
